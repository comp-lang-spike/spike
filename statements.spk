

class Stmt {
    obj next;
    
    self init {
        next = null;
        return self;
    }
    
    next = aStmt { next = aStmt; }
    
    source(sourcePathname) {
        // XXX
        return self;
    }
    
    asModuleDef() {
        // XXX
        return self;
    }
    
    graphviz(stream) {
        stream.printf("    n%d[label=\"%s\"];\n", self.id, self.printString);
        
        if (next !== null)
            next.graphviz(stream);
        
        self childrenDo: [
            obj name, child;
            if (child !== null)
                child.graphviz(stream);
            ];
        
        if (next !== null)
            stream.printf("    n%d->n%d[label=\"next\"];\n", self.id, next.id);
        
        self childrenDo: [
            obj name, child;
            if (child !== null)
                stream.printf("    n%d->n%d[label=\"%s\"];\n", self.id, child.id, name);
            ];
    }
}


//------------------------------------------------------------------------
// expression statements

class ExprStmt : Stmt {
    obj expr;
    
    self init expr: e top: t bottom: b {
        super init;
        expr = e;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("expr", expr);
    }
    
    
    check(outer, checker, outerPass) {
        if (expr !== null) {
            checker.checkExpr(expr, self, checker, outerPass);
        }
    }
}


//------------------------------------------------------------------------
// compound statements

class CompoundStmt : Stmt {
    obj top;
    
    self init expr: e top: t bottom: b {
        super init;
        top = t;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("top", top);
    }
    
    
    check(outer, checker, outerPass) {
        obj st;
        
        if (outerPass != $bind)
            return;
        
        st = checker.symbolTable;
        st.enterScope(false);
        
        self.checkStatements(checker, $define);
        self.checkStatements(checker, $bind);
        self.checkStatements(checker, $pass3);
        
        st.exitScope();
    }
    
    
    checkStatements(checker, pass) {
        checker.checkStmtList(top, self, pass);
    }
}


//------------------------------------------------------------------------
// control statements

class BreakStmt : Stmt {
    self init expr: e top: t bottom: b {
        return super init;
    }
    
    
    self childrenDo: aBlock {}
    
    
    check(outer, checker, outerPass) {}
}


class ContinueStmt : Stmt {
    self init expr: e top: t bottom: b {
        return super init;
    }
    
    
    self childrenDo: aBlock {}
    
    
    check(outer, checker, outerPass) {}
}


class DoWhileStmt : Stmt {
    obj expr;
    obj top;
    
    self init expr: e top: t bottom: b {
        super init;
        expr = e;
        top = t;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("expr", expr);
        aBlock("top", top);
    }
    
    
    check(outer, checker, outerPass) {
        checker.checkExpr(expr, self, outerPass);
        top.check(self, checker, outerPass);
    }
}


class ForStmt : Stmt {
    obj init, expr, incr;
    obj top;
    
    self init expr1: expr1 expr2: expr2 expr3: expr3 body: body {
        super init;
        init = expr1;
        expr = expr2;
        incr = expr3;
        top = body;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("init", init);
        aBlock("expr", expr);
        aBlock("incr", incr);
        aBlock("top", top);
    }
    
    
    check(outer, checker, outerPass) {
        if (init !== null)
            checker.checkExpr(init, self, outerPass);
        if (expr !== null)
            checker.checkExpr(expr, self, outerPass);
        if (incr !== null)
            checker.checkExpr(incr, self, outerPass);
        top.check(self, checker, outerPass);
    }
}


class IfElseStmt : Stmt {
    obj expr;
    obj top, bottom;
    
    self init expr: e top: t bottom: b {
        super init;
        expr = e;
        top = t;
        bottom = b;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("expr", expr);
        aBlock("top", top);
        aBlock("bottom", bottom);
    }
    
    
    check(outer, checker, outerPass) {
        checker.checkExpr(expr, self, outerPass);
        top.check(self, checker, outerPass);
        if (bottom !== null)
            bottom.check(self, checker, outerPass);
    }
}


class ReturnStmt : Stmt {
    obj expr;
    
    self init expr: e top: t bottom: b {
        super init;
        expr = e;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("expr", expr);
    }
    
    
    check(outer, checker, outerPass) {
        if (expr !== null)
            checker.checkExpr(expr, self, checker, outerPass);
    }
}


class WhileStmt : Stmt {
    obj expr;
    obj top;
    
    self init expr: e top: t bottom: b {
        super init;
        expr = e;
        top = t;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("expr", expr);
        aBlock("top", top);
    }
    
    
    check(outer, checker, outerPass) {
        checker.checkExpr(expr, self, outerPass);
        top.check(self, checker, outerPass);
    }
}


class YieldStmt : Stmt {
    obj expr;
    
    self init expr: e top: t bottom: b {
        super init;
        expr = e;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("expr", expr);
    }
    
    
    check(outer, checker, outerPass) {
        if (expr !== null)
            checker.checkExpr(expr, self, checker, outerPass);
    }
}


//------------------------------------------------------------------------
// definition statements

class ClassDef : Stmt {
}


class MethodDef : Stmt {
    obj expr;
    obj top;
    obj name, namespace, fixedArgList, varArg;
    obj minArgumentCount, maxArgumentCount, localCount;
    
    self init expr: e top: t bottom: b {
        super init;
        expr = e;
        top = t;
        return self;
    }
    
    self name: n namespace: ns fixed: fixed var: var {
        name = n;
        namespace = ns;
        fixedArgList = fixed;
        varArg = var;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("expr", expr);
        aBlock("top", top);
    }
    
    
    check(outer, checker, outerPass) {
        
        checker.checkDeclSpecs(expr.declSpecs, outerPass);
        
        if (outerPass === $bind) {
            expr.checkMethodDeclarator(self, outer, checker);
            
        } else if (outerPass === $define) {
            obj st, innerPass;
            
            st = checker.symbolTable;
            if (outer === null || outer.class !== ClassDef) {
                /* naked (global) function -- enter module instance context */
                st.enterScope(true);
            }
            st.enterScope(true);
            
            /* declare function arguments */
            self.declareArguments(checker);
            
            self.checkStatements(checker, $define);
            self.checkStatements(checker, $bind);
            self.checkStatements(checker, $pass3);
            
            localCount = checker.symbolTable.currentScope.context.nDefs -
                         maxArgumentCount -
                         (varArg === null ? 0 : 1);
            
            st.exitScope();
            if (outer === null || outer.class !== ClassDef)
                st.exitScope();
        }
    }
    
    
    declareArguments(checker) {
        obj arg, def;
        
        minArgumentCount = maxArgumentCount = 0;
        
        for (arg = fixedArgList; arg !== null; arg = arg.nextArg) {
            def = arg.stripDeclarator();
            if (def === null)
                break;
            
            checker.checkDeclSpecs(def.declSpecs, $bind);
            checker.symbolTable.insert(def, checker.requestor);
            ++minArgumentCount;
            ++maxArgumentCount;
        }
        
        for ( ; arg !== null; arg = arg.nextArg) {
            if (arg.class == AssignExpr) {
                def = arg.left;
            } else {
                def = arg;
                if (def.class === NameExpr) {
                    checker.notifier nonDefaultArgumentFollowsDefaultArgument: arg;
                    /* fall though and define it, to reduce the number of errors */
                }
            }
            
            def = arg.stripDeclarator();
            if (def === null) {
                checker.notifier invalidArgumentDefinition: arg;
                continue;
            }
            
            checker.symbolTable.insert(def, checker.requestor);
            ++maxArgumentCount;
        }
        
        if (varArg !== null) {
            if (varArg.class !== NameExpr)
                checker.notifier invalidArgumentDefinition: varArg;
            else
                checker.symbolTable.insert(varArg, checker.requestor);
        }
    }
    
    
    checkStatements(checker, innerPass) {
        obj arg;
        
        for (arg = fixedArgList; arg !== null; arg = arg.nextArg) {
            if (arg.class === AssignExpr)
                checker.checkExpr(arg.right, self, innerPass);
        }
        
        top.checkStatements(checker, innerPass);
    }
}


class ModuleDef : Stmt {
}


class TypeDef : Stmt {
}


class VarDef : Stmt {
    obj expr;
    
    self init expr: e top: t bottom: b {
        super init;
        expr = e;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("expr", expr);
    }
    
    
    check(outer, checker, outerPass) {
        obj e, def;
        
        checker.checkDeclSpecs(expr.declSpecs, outerPass);
        
        for (e = expr; e; e = e.next) {
            if (e.class === AssignExpr) {
                def = e.left;
                checker.checkExpr(e.right, self, outerPass);
            } else {
                def = e;
            }
            while (def.class === UnaryOpExpr && def.oper == $operInd)
                def = def.left;
            if (def.class !== NameExpr) {
                if (outerPass === $declare)
                    checker.notifier invalidVariableDefinition: def;
                continue;
            }
            if (outerPass === $declare)
                checker.symbolTable.insert(def, checker.requestor);
        }
    }
}



//------------------------------------------------------------------------
// pragma statements

class SourcePragma {
    obj source;
    
    
    self childrenDo: aBlock {
    }
    
    
    check(outer, checker, outerPass) {
        checker.requestor.source = source;
    }
}
