

class Expr {
    obj declSpecs;
    obj next, nextArg;
    
    self init {
        declSpecs = null;
        next = null;
        nextArg = null;
        return self;
    }
    
    
    isSelf { return false; }
    
    
    graphviz(stream) {
        stream.printf("    n%d[label=\"%s\"];\n", self.id, self.printString);
        
        if (nextArg !== null)
            nextArg.graphviz(stream);
        if (next !== null)
            next.graphviz(stream);
        
        self childrenDo: [
            obj name, child;
            if (child !== null)
                child.graphviz(stream);
            ];
        
        if (nextArg !== null)
            stream.printf("    n%d->n%d[label=\"nextArg\"];\n", self.id, nextArg.id);
        if (next !== null)
            stream.printf("    n%d->n%d[label=\"next\"];\n", self.id, next.id);
        
        self childrenDo: [
            obj name, child;
            if (child !== null)
                stream.printf("    n%d->n%d[label=\"%s\"];\n", self.id, child.id, name);
            ];
    }
    
    
    checkMethodDeclarator(methodDef, outer, checker) {
        checker.notifier invalidMethodDeclarator: self;
    }
    
    
    checkMethodDeclaratorLHS(methodDef, rhs, outer, checker) {
        checker.notifier invalidMethodDeclarator: self;
    }
    
    
    stripDeclarator() {
        return null;
    }
    
    
    declSpecs = ds { declSpecs = ds; }
    next = anExpr { next = anExpr; }
    nextArg = anExpr { nextArg = anExpr; }
    
    //concat() {}
    //left() {}
}



//------------------------------------------------------------------------
// primary expressions

class NameExpr : Expr {
    obj sym;
    // definition
    obj index, pushOpcode, storeOpcode;
    // reference
    obj def;
    // both
    obj level;
    
    self init tokenValue: v {
        super init;
        sym = v;
        return self;
    }
    
    
    self childrenDo: aBlock {
    }
    
    
    self definition level: l index: i pushOpcode: po storeOpcode: so {
        level = l;
        index = i;
        if (pushOpcode == Opcode.nop) { /* not built-in scope */
            pushOpcode = po;
            storeOpcode = so;
        }
    }
    
    
    self reference def: d level: l {
        def = d;
        level = l;
    }
    
    
    isSpec { return def !== null && def.isTypeDef; }
    isSelf { return sym.isSelf; }
    
    
    check(stmt, checker, pass) {
        if (pass === $bind)
            checker.symbolTable.bind(self, checker.requestor);
    }
    
    
    checkMethodDeclarator(methodDef, outer, checker) {
        methodDef name: sym namespace: $nsRValue fixed: null var: null;
    }
    
    
    checkMethodDeclaratorLHS(methodDef, rhs, outer, checker) {
        methodDef name: sym namespace: $nsLValue fixed: rhs var: null;
    }
    
    
    stripDeclarator() {
        return self;
    }
}


class LiteralExpr : Expr {
    obj value;
    
    self init tokenValue: v {
        super init;
        value = v;
        return self;
    }
    
    self childrenDo: aBlock {
    }
    
    value { return value; }
    
    
    check(stmt, checker, pass) {
    }
}


class CompoundExpr : Expr {
    obj right;
    
    self init oper: o cond: c left: l right: r {
        super init;
        right = r;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("right", right);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkArgList(right, stmt, pass);
    }
}


class BlockExpr : Expr {
    obj stmtList, right;
    obj index, argumentCount, localCount;
    
    self init stmtList: l expr: e {
        super init;
        stmtList = l;
        right = e;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("stmtList", stmtList);
        aBlock("right", right);
    }
    
    
    check(stmt, checker, outerPass) {
        obj arg, firstStmt, s, innerPass, st;
        
        if (outerPass !== $bind)
            return;
        
        st = checker.symbolTable;
        st.enterScope(false);
        
        firstStmt = stmtList;
        
        index = 0;
        argumentCount = 0;
        
        if (firstStmt !== null && firstStmt.class === VarDef) {
            /* declare block arguments */
            for (arg = firstStmt.expr; arg; arg = arg.next) {
                if (arg.class !== NameExpr) {
                    checker.notifier invalidArgumentDefinition: arg;
                    continue;
                }
                checker.symbolTable.insert(arg, checker.requestor);
                ++argumentCount;
            }
            
            /* The 'index' of the block itself is the index of the first
             * argument.  The interpreter uses this index to find the
             * destination the block arguments; see Spk_OPCODE_CALL_BLOCK.
             */
            index = firstStmt.expr.index;
            
            firstStmt = firstStmt.next;
        }
        
        self.checkStmtList(stmt, checker, $define);
        self.checkStmtList(stmt, checker, $bind);
        self.checkStmtList(stmt, checker, $pass3);
        
        /* XXX: this is only needed for arbitrary nesting */
        localCount = checker.symbolTable.currentScope.context.nDefs - argumentCount;
        
        st.exitScope();
    }
    
    
    checkStmtList(stmt, checker, innerPass) {
        if (stmtList !== null)
            checker.checkStmtList(stmtList, stmt, innerPass);
        if (right !== null)
            checker.checkExpr(right, stmt, innerPass);
    }

}



//------------------------------------------------------------------------
// postfix expressions

class CallExpr : Expr {
    obj oper;
    obj left, right, var;
    
    self init oper: o func: func fixed: fixed var: v {
        super init;
        oper = o;
        left = func;
        right = fixed;
        var = v;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
        aBlock("right", right);
        aBlock("var", var);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
        checker.checkArgList(right, stmt, pass);
        if (var !== null)
            checker.checkExpr(var, stmt, pass);
    }
    
    
    checkMethodDeclarator(methodDef, outer, checker) {
        obj name;
        
        if (left.class !== NameExpr) {
            checker.notifier invalidMethodDeclarator: self;
            return;
        }
        
        if (left.isSelf) {
            name = Oper.operCallSelector(oper);
        } else {
            /*
             * XXX: Should we allow "foo[...] {}" as a method
             * definition?  More generally, could the method
             * declarator be seen as the application of an inverse
             * thingy?
             */
            if (oper !== $operApply) {
                checker.notifier invalidMethodDeclarator: self;
                return;
            }
            
            name = left.sym;
        }
        
        if (outer === null || outer.class !== ClassDef) {
            /* declare naked functions */
            checker.symbolTable.insert(left, checker.requestor);
        }
        
        methodDef name: name namespace: $nsRValue fixed: right var: var;
    }
    
    
    checkMethodDeclaratorLHS(methodDef, rhs, outer, checker) {
        obj name;
        
        if (oper !== $operIndex || !left.isSelf) {
            checker.notifier invalidMethodDeclarator: self;
            return;
        }
        
        name = checker.symbolTable symbolNodeForSymbol: $__index__;
        
        /* chain-on the new value arg */
        right.nextArg = rhs;
        
        methodDef name: name namespace: $nsLValue fixed: right var: null;
    }
}


class AttrExpr : Expr {
    obj left;
    
    self init oper: o cond: c left: l right: r {
        super init;
        left = l;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
    }
}


class PostOpExpr : Expr {
    obj oper;
    obj left;
    
    self init oper: o cond: c left: l right: r {
        super init;
        oper = o;
        left = l;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
    }
}


//------------------------------------------------------------------------
// unary expressions

class UnaryOpExpr : Expr {
    obj oper;
    obj left;
    
    self init oper: o cond: c left: l right: r {
        super init;
        oper = o;
        left = l;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
    }
    
    
    checkMethodDeclarator(methodDef, outer, checker) {
        obj name;
        
        /* XXX: This can only be meaningfully composed with Spk_EXPR_CALL. */
        if (oper === $operInd)
            return left.checkMethodDeclarator(methodDef, outer, checker);
        
        if (!left.isSelf) {
            checker.notifier invalidMethodDeclarator: self;
            return;
        }
        
        name = checker.symbolTable.operSelector(oper);
        methodDef name: name namespace: $nsRValue fixed: null var: null;
    }
    
    
    stripDeclarator() {
        if (oper === $operInd)
            return left.stripDeclarator();
        return null;
    }
}


class PreOpExpr : Expr {
    obj oper;
    obj left;
    
    self init oper: o cond: c left: l right: r {
        super init;
        oper = o;
        left = l;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
    }
}



//------------------------------------------------------------------------
// binary expressions

class BinaryOpExpr : Expr {
    obj oper;
    obj left, right;
    
    self init oper: o cond: c left: l right: r {
        super init;
        oper = o;
        left = l;
        right = r;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
        aBlock("right", right);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
        checker.checkExpr(right, stmt, pass);
    }
    
    
    checkMethodDeclarator(methodDef, outer, checker) {
        obj name, fixed;
        
        if (!left.isSelf) {
            checker.notifier invalidMethodDeclarator: self;
            return;
        }
        
        fixed = null;
        if (right.class === NameExpr) {
            name = checker.symbolTable.operSelector(oper);
            fixed = right;
        } else if (right.class === LiteralExpr && right.value == 1) {
            if (oper === $operAdd) {
                name = checker.symbolTable.operSelector($operSucc);
            } else if (oper === $operSub) {
                name = checker.symbolTable.operSelector($operPred);
            } else {
                checker.notifier invalidMethodDeclarator: self;
                return;
            }
        } else {
            checker.notifier invalidMethodDeclarator: self;
            return;
        }
        
        methodDef name: name namespace: $nsRValue fixed: fixed var: null;
    }
}


class IdExpr : Expr {
    obj left, right;
    
    self init oper: o cond: c left: l right: r {
        super init;
        left = l;
        right = r;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
        aBlock("right", right);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
        checker.checkExpr(right, stmt, pass);
    }
}


class NIExpr : Expr {
    obj left, right;
    
    self init oper: o cond: c left: l right: r {
        super init;
        left = l;
        right = r;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
        aBlock("right", right);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
        checker.checkExpr(right, stmt, pass);
    }
}


class AttrVarExpr : Expr {
    obj left, right;
    
    self init oper: o cond: c left: l right: r {
        super init;
        left = l;
        right = r;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
        aBlock("right", right);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
        checker.checkExpr(right, stmt, pass);
    }
}



//------------------------------------------------------------------------
// logical expressions

class AndExpr : Expr {
    obj left, right;
    
    self init oper: o cond: c left: l right: r {
        super init;
        left = l;
        right = r;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
        aBlock("right", right);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
        checker.checkExpr(right, stmt, pass);
    }
}


class OrExpr : Expr {
    obj left, right;
    
    self init oper: o cond: c left: l right: r {
        super init;
        left = l;
        right = r;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
        aBlock("right", right);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
        checker.checkExpr(right, stmt, pass);
    }
}



//------------------------------------------------------------------------
// conditional expressions

class CondExpr : Expr {
    obj cond, left, right;
    
    self init oper: o cond: c left: l right: r {
        super init;
        cond = c;
        left = l;
        right = r;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("cond", cond);
        aBlock("left", left);
        aBlock("right", right);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(cond, stmt, pass);
        checker.checkExpr(left, stmt, pass);
        checker.checkExpr(right, stmt, pass);
    }
}



//------------------------------------------------------------------------
// keyword expressions

class KeywordExpr : Expr {
    obj left, right;
    obj keywords;
    
    self init oper: o cond: c left: l right: r {
        super init;
        left = l;
        right = r;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
        aBlock("right", right);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
        checker.checkArgList(right, stmt, pass);
    }
    
    
    checkMethodDeclarator(methodDef, outer, checker) {
        obj name;
        
        if (!left.isSelf) {
            checker.notifier invalidMethodDeclarator: self;
            return;
        }
        
        name = checker.symbolTable symbolNodeForSymbol: keywords;
        methodDef name: name namespace: $nsRValue fixed: right var: null;
    }
}



//------------------------------------------------------------------------
// assignment expressions

class AssignExpr : Expr {
    obj left, right;
    
    self init oper: o cond: c left: l right: r {
        super init;
        left = l;
        right = r;
        return self;
    }
    
    
    self childrenDo: aBlock {
        aBlock("left", left);
        aBlock("right", right);
    }
    
    
    check(stmt, checker, pass) {
        checker.checkExpr(left, stmt, pass);
        checker.checkExpr(right, stmt, pass);
    }
    
    
    checkMethodDeclarator(methodDef, outer, checker) {
        if (right.class !== NameExpr) {
            checker.notifier invalidMethodDeclarator: self;
            return;
        }
        
        left.checkMethodDeclaratorLHS(methodDef, right, outer, checker);
    }
}

