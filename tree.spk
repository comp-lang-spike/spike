
class TreeBuilder {
    exprAnd(oper, cond, left, right)      { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprAssign(oper, cond, left, right)   { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprAttr(oper, cond, left, right)     { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprAttrVar(oper, cond, left, right)  { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprBinaryOp(oper, cond, left, right) { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprBlock(oper, cond, left, right)    { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprCall(oper, func, fixed, var)      { return CallExpr.new init oper: oper func: func fixed: fixed var: var; }
    exprCompound(oper, cond, left, right) { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprCond(oper, cond, left, right)     { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprId(oper, cond, left, right)       { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprKeyword(oper, cond, left, right)  { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprLiteral(oper, cond, left, right, value) {
        return LiteralExpr.new init oper: oper cond: cond left: left right: right value: value;
    }
    exprName(oper, cond, left, right, sym) {
        return NameExpr.new init oper: oper cond: cond left: left right: right sym: sym;
    }
    exprNI(oper, cond, left, right)       { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprOr(oper, cond, left, right)       { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprPostOp(oper, cond, left, right)   { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprPreOp(oper, cond, left, right)    { return Expr.new init oper: oper cond: cond left: left right: right; }
    exprUnaryOp(oper, cond, left, right)  { return Expr.new init oper: oper cond: cond left: left right: right; }
    
    stmtBreak(expr, top, bottom)    { return Stmt.new init expr: expr top: top bottom: bottom; }
    stmtCompound(expr, top, bottom) { return Stmt.new init expr: expr top: top bottom: bottom; }
    stmtContinue(expr, top, bottom) { return Stmt.new init expr: expr top: top bottom: bottom; }
    stmtDefClass() {}
    stmtDefMethod(expr, top, bottom) { return Stmt.new init expr: expr top: top bottom: bottom; }
    stmtDefModule() {}
    stmtDefType() {}
    stmtDefVar() {}
    stmtDoWhile(expr, top, bottom)  { return Stmt.new init expr: expr top: top bottom: bottom; }
    stmtExpr(expr, top, bottom)     { return Stmt.new init expr: expr top: top bottom: bottom; }
    stmtFor(expr, top, bottom)      { return Stmt.new init expr: expr top: top bottom: bottom; }
    stmtIfElse(expr, top, bottom)   { return Stmt.new init expr: expr top: top bottom: bottom; }
    stmtPragmaSource() {}
    stmtReturn(expr, top, bottom)   { return Stmt.new init expr: expr top: top bottom: bottom; }
    stmtWhile(expr, top, bottom)    { return Stmt.new init expr: expr top: top bottom: bottom; }
    stmtYield(expr, top, bottom)    { return Stmt.new init expr: expr top: top bottom: bottom; }
}
